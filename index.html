<!DOCTYPE html>
<html>
<head>
    <title>NecroMancer: Legado do Orbe Bitwise (Prólogo)</title>
    <style>
        body { margin: 0; overflow: hidden; background-color: #000; }
        canvas { display: block; }
    </style>
    <script src="https://cdn.jsdelivr.net/npm/gl-matrix@2.8.1/dist/gl-matrix-min.js"></script>
</head>
<body>
    <canvas id="glCanvas"></canvas>
    <script>
        // I. Inicialização do WebGL
        const canvas = document.getElementById('glCanvas');
        const gl = canvas.getContext('webgl2');
        if (!gl) throw new Error('WebGL 2 não suportado');
        function resizeCanvas() { canvas.width = window.innerWidth; canvas.height = window.innerHeight; gl.viewport(0, 0, canvas.width, canvas.height); }
        window.addEventListener('resize', resizeCanvas); resizeCanvas();
        gl.enable(gl.DEPTH_TEST); gl.enable(gl.CULL_FACE); gl.cullFace(gl.BACK); gl.enable(gl.BLEND); gl.blendFunc(gl.SRC_ALPHA, gl.ONE_MINUS_SRC_ALPHA);
        gl.clearColor(0.0, 0.0, 0.0, 1.0); gl.clear(gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT);

        // II. Definição e Compilação dos Shaders
        const vsSource = `#version 300 es in vec4 aVertexPosition; in vec3 aVertexNormal; in vec2 aTextureCoord; uniform mat4 uModelViewMatrix; uniform mat4 uProjectionMatrix; uniform mat4 uNormalMatrix; out vec3 vFragPos; out vec3 vNormal; out vec2 vTextureCoord; void main(void) { gl_Position = uProjectionMatrix * uModelViewMatrix * aVertexPosition; vFragPos = vec3(uModelViewMatrix * aVertexPosition); vNormal = mat3(uNormalMatrix) * aVertexNormal; vTextureCoord = aTextureCoord; }`;
        const fsSource = `#version 300 es precision highp float; in vec3 vFragPos; in vec3 vNormal; in vec2 vTextureCoord; out vec4 fragColor; uniform sampler2D uSampler; uniform vec3 uLightPosition; uniform vec3 uViewPosition; void main(void) { float ambientStrength=0.1; vec3 ambient=ambientStrength*vec3(1.0); vec3 norm=normalize(vNormal); vec3 lightDir=normalize(uLightPosition-vFragPos); float diff=max(dot(norm,lightDir),0.0); vec3 diffuse=diff*vec3(1.0); float specularStrength=0.5; vec3 viewDir=normalize(uViewPosition-vFragPos); vec3 reflectDir=reflect(-lightDir,norm); float spec=pow(max(dot(viewDir,reflectDir),0.0),32.0); vec3 specular=specularStrength*spec*vec3(1.0); vec4 textureColor=texture(uSampler,vTextureCoord); vec3 result=(ambient+diffuse+specular)*textureColor.rgb; fragColor=vec4(result,textureColor.a); }`;
        function initShaderProgram(gl, vsSource, fsSource) {
            function loadShader(gl, type, source) { const shader = gl.createShader(type); gl.shaderSource(shader, source); gl.compileShader(shader); if (!gl.getShaderParameter(shader, gl.COMPILE_STATUS)) { console.error('Erro compilando shader:', gl.getShaderInfoLog(shader)); gl.deleteShader(shader); return null; } return shader; }
            const vertexShader = loadShader(gl, gl.VERTEX_SHADER, vsSource); const fragmentShader = loadShader(gl, gl.FRAGMENT_SHADER, fsSource); const shaderProgram = gl.createProgram(); gl.attachShader(shaderProgram, vertexShader); gl.attachShader(shaderProgram, fragmentShader); gl.linkProgram(shaderProgram); if (!gl.getProgramParameter(shaderProgram, gl.LINK_STATUS)) { console.error('Erro linkando programa:', gl.getProgramInfoLog(shaderProgram)); return null; } return shaderProgram;
        }
        const shaderProgram = initShaderProgram(gl, vsSource, fsSource);
        const programInfo = { program: shaderProgram, attribLocations: { vertexPosition: gl.getAttribLocation(shaderProgram, 'aVertexPosition'), vertexNormal: gl.getAttribLocation(shaderProgram, 'aVertexNormal'), textureCoord: gl.getAttribLocation(shaderProgram, 'aTextureCoord'), }, uniformLocations: { projectionMatrix: gl.getUniformLocation(shaderProgram, 'uProjectionMatrix'), modelViewMatrix: gl.getUniformLocation(shaderProgram, 'uModelViewMatrix'), normalMatrix: gl.getUniformLocation(shaderProgram, 'uNormalMatrix'), uSampler: gl.getUniformLocation(shaderProgram, 'uSampler'), uLightPosition: gl.getUniformLocation(shaderProgram, 'uLightPosition'), uViewPosition: gl.getUniformLocation(shaderProgram, 'uViewPosition'), } };

        // III. Definição da Geometria do Cubo
        const positions = [-1,-1,1,1,-1,1,1,1,1,-1,1,1, -1,-1,-1,-1,1,-1,1,1,-1,1,-1,-1, -1,1,-1,-1,1,1,1,1,1,1,1,-1, -1,-1,-1,1,-1,-1,1,-1,1,-1,-1,1, 1,-1,-1,1,1,-1,1,1,1,1,-1,1, -1,-1,-1,-1,-1,1,-1,1,1,-1,1,-1];
        const normals = [0,0,1,0,0,1,0,0,1,0,0,1, 0,0,-1,0,0,-1,0,0,-1,0,0,-1, 0,1,0,0,1,0,0,1,0,0,1,0, 0,-1,0,0,-1,0,0,-1,0,0,-1,0, 1,0,0,1,0,0,1,0,0,1,0,0, -1,0,0,-1,0,0,-1,0,0,-1,0,0];
        const textureCoords = [0,0,1,0,1,1,0,1, 1,0,1,1,0,1,0,0, 0,1,0,0,1,0,1,1, 1,1,0,1,0,0,1,0, 1,0,1,1,0,1,0,0, 0,0,1,0,1,1,0,1];
        const indices = [0,1,2,0,2,3,4,5,6,4,6,7,8,9,10,8,10,11,12,13,14,12,14,15,16,17,18,16,18,19,20,21,22,20,22,23];
        const buffers = {};
        buffers.position = gl.createBuffer(); gl.bindBuffer(gl.ARRAY_BUFFER, buffers.position); gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(positions), gl.STATIC_DRAW);
        buffers.normal = gl.createBuffer(); gl.bindBuffer(gl.ARRAY_BUFFER, buffers.normal); gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(normals), gl.STATIC_DRAW);
        buffers.textureCoord = gl.createBuffer(); gl.bindBuffer(gl.ARRAY_BUFFER, buffers.textureCoord); gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(textureCoords), gl.STATIC_DRAW);
        buffers.indices = gl.createBuffer(); gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, buffers.indices); gl.bufferData(gl.ELEMENT_ARRAY_BUFFER, new Uint16Array(indices), gl.STATIC_DRAW);

        // IV. Configuração das Matrizes
        const fieldOfView = 45 * Math.PI / 180; const aspect = gl.canvas.clientWidth / gl.canvas.clientHeight; const zNear = 0.1; const zFar = 100.0; const projectionMatrix = mat4.create(); mat4.perspective(projectionMatrix, fieldOfView, aspect, zNear, zFar);
        const modelViewMatrix = mat4.create(); const normalMatrix = mat4.create(); const cubePosition = [0.0, 0.0, -6.0]; let cubeRotation = 0.0;

        // V. Loop de Renderização
        let then = 0; function render(now) { now *= 0.001; const deltaTime = now - then; then = now; cubeRotation += deltaTime; gl.clear(gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT); mat4.identity(modelViewMatrix); mat4.translate(modelViewMatrix, modelViewMatrix, cubePosition); mat4.rotate(modelViewMatrix, modelViewMatrix, cubeRotation, [0,0,1]); mat4.rotate(modelViewMatrix, modelViewMatrix, cubeRotation*0.7, [0,1,0]); mat4.rotate(modelViewMatrix, modelViewMatrix, cubeRotation*0.3, [1,0,0]); mat4.invert(normalMatrix, modelViewMatrix); mat4.transpose(normalMatrix, normalMatrix); gl.useProgram(programInfo.program); gl.uniformMatrix4fv(programInfo.uniformLocations.projectionMatrix, false, projectionMatrix); gl.uniformMatrix4fv(programInfo.uniformLocations.modelViewMatrix, false, modelViewMatrix); gl.uniformMatrix4fv(programInfo.uniformLocations.normalMatrix, false, normalMatrix); gl.uniform3fv(programInfo.uniformLocations.uLightPosition, [5,5,5]); gl.uniform3fv(programInfo.uniformLocations.uViewPosition, [0,0,0]); gl.bindBuffer(gl.ARRAY_BUFFER, buffers.position); gl.vertexAttribPointer(programInfo.attribLocations.vertexPosition, 3, gl.FLOAT, false, 0, 0); gl.enableVertexAttribArray(programInfo.attribLocations.vertexPosition); gl.bindBuffer(gl.ARRAY_BUFFER, buffers.normal); gl.vertexAttribPointer(programInfo.attribLocations.vertexNormal, 3, gl.FLOAT, false, 0, 0); gl.enableVertexAttribArray(programInfo.attribLocations.vertexNormal); gl.bindBuffer(gl.ARRAY_BUFFER, buffers.textureCoord); gl.vertexAttribPointer(programInfo.attribLocations.textureCoord, 2, gl.FLOAT, false, 0, 0); gl.enableVertexAttribArray(programInfo.attribLocations.textureCoord); gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, buffers.indices); gl.uniform1i(programInfo.uniformLocations.uSampler, 0); gl.drawElements(gl.TRIANGLES, 36, gl.UNSIGNED_SHORT, 0); requestAnimationFrame(render); } requestAnimationFrame(render);
    </script>
</body>
</html>
